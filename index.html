<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>익명 1:1 채팅</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { height: 100%; }
    .scrollbar-thin::-webkit-scrollbar { height: 6px; width: 6px; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 8px; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-900">
  <div class="max-w-md mx-auto px-4 py-8">
    <header class="flex items-center justify-between mb-6">
      <h1 class="text-2xl font-bold">익명 1:1 채팅</h1>
      <span id="authBadge" class="text-xs text-slate-500" title="">연결 준비중...</span>
    </header>

    <!-- 홈 화면 -->
    <section id="home" class="rounded-2xl bg-white shadow p-6 hidden">
      <h2 class="text-lg font-semibold mb-2">랜덤 익명 매칭</h2>
      <p class="text-slate-600 mb-4">원하는 방식으로 시작하세요.</p>

      <!-- 자동 매칭 -->
      <div id="idleActions" class="space-y-3">
        <button id="btnStart" class="w-full py-3 rounded-xl bg-emerald-600 text-white font-semibold">
          익명 채팅 시작하기 (자동 매칭)
        </button>
      </div>

      <!-- 매칭중 -->
      <div id="matching" class="hidden flex flex-col items-center justify-center gap-3 py-8">
        <div class="animate-spin w-8 h-8 border-4 border-slate-200 border-t-indigo-600 rounded-full"></div>
        <p class="text-sm text-slate-700 text-center">
          실제 사람이 들어올 때까지 대기 중입니다.<br/>매칭되면 자동으로 채팅방으로 이동해요.
        </p>
        <button id="btnCancel" class="px-4 py-2 rounded-lg bg-slate-200 text-slate-800 text-sm">취소</button>
      </div>

      <!-- 수동 모드 (방 코드) -->
      <div class="mt-6 border-t pt-4 space-y-2">
        <h3 class="text-sm font-semibold text-slate-600">수동 입장 (방 코드 공유)</h3>
        <button id="btnHostManual" class="w-full py-2 rounded-lg bg-slate-800 text-white text-sm">호스트 방 만들기</button>

        <div class="flex gap-2">
          <input id="roomCodeInput" class="flex-1 px-3 py-2 rounded-lg border" placeholder="방 코드 입력(문서 ID)" />
          <button id="btnJoinManual" class="px-4 py-2 rounded-lg bg-indigo-600 text-white text-sm">게스트 입장</button>
        </div>

        <div id="shareHint" class="hidden text-xs text-slate-600 bg-slate-100 rounded-lg p-2">
          내 방 코드: <b id="roomCodeText"></b>
          <button id="btnCopyCode" class="ml-2 px-2 py-0.5 rounded bg-slate-300 text-slate-800">복사</button>
          <span class="ml-1 text-[11px] text-slate-500">(친구가 위 코드를 입력하면 연결됩니다)</span>
        </div>
      </div>

      <!-- 디버그 -->
      <details class="mt-4 text-sm text-slate-500">
        <summary class="cursor-pointer">연결 상태</summary>
        <div class="mt-2 space-y-1">
          <div>내 UID: <span id="dbgUid">-</span></div>
          <div>룸 ID: <span id="dbgRoom">-</span></div>
          <div>역할: <span id="dbgRole">-</span></div>
        </div>
      </details>
    </section>

    <!-- 채팅 화면 -->
    <section id="chat" class="hidden rounded-2xl bg-white shadow flex flex-col h-[70vh] mt-6">
      <div class="flex items-center justify-between p-4 border-b">
        <div>
          <div class="text-sm text-slate-500">상대와 익명 채팅</div>
          <div id="nickbar" class="font-semibold"></div>
          <div id="statusbar" class="text-xs text-slate-500"></div>
        </div>
        <button id="btnLeave" class="px-3 py-2 rounded-lg bg-slate-200 text-sm">나가기</button>
      </div>

      <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-2 scrollbar-thin bg-slate-50"></div>

      <form id="messageForm" class="p-3 border-t flex gap-2">
        <input id="messageInput" class="flex-1 px-3 py-2 rounded-lg border" placeholder="메시지를 입력..." autocomplete="off" />
        <button class="px-4 py-2 rounded-lg bg-indigo-600 text-white">전송</button>
      </form>
    </section>
  </div>

  <!-- Firebase SDK (Compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

  <script>
    // === Firebase 초기화 ===
    const firebaseConfig = {
      apiKey: "AIzaSyACfmI0SvAFEEjlFTkkoI1leGoZ-IYj9iI",
      authDomain: "eekmyoung-b85f9.firebaseapp.com",
      projectId: "eekmyoung-b85f9",
      storageBucket: "eekmyoung-b85f9.appspot.com",
      messagingSenderId: "576568352493",
      appId: "1:576568352493:web:57784642885f24115576e4",
      measurementId: "G-ZQYHMN5BBL"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    auth.signInAnonymously().catch(console.error);

    // === DOM ===
    const authBadge = document.getElementById('authBadge');
    const home = document.getElementById('home');
    const matchingBox = document.getElementById('matching');
    const btnStart = document.getElementById('btnStart');
    const btnCancel = document.getElementById('btnCancel');
    const btnLeave = document.getElementById('btnLeave');
    const dbgUid = document.getElementById('dbgUid');
    const dbgRoom = document.getElementById('dbgRoom');
    const dbgRole = document.getElementById('dbgRole');
    const chatSec = document.getElementById('chat');
    const nickbar = document.getElementById('nickbar');
    const statusbar = document.getElementById('statusbar');
    const messages = document.getElementById('messages');
    const form = document.getElementById('messageForm');
    const input = document.getElementById('messageInput');

    const btnHostManual = document.getElementById('btnHostManual');
    const btnJoinManual = document.getElementById('btnJoinManual');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const shareHint = document.getElementById('shareHint');
    const roomCodeText = document.getElementById('roomCodeText');
    const btnCopyCode = document.getElementById('btnCopyCode');

    // === 상태 ===
    let currentUser = null;
    let currentRoomId = null;
    let currentRole = null;   // 'host' | 'guest'
    let roomUnsub = null;
    let msgUnsub = null;
    let roomRef = null;

    // 매칭 대기열 상태
    let waitingDocRef = null;
    let waitingUnsub = null;
    let waitingHbTimer = null;

    // 룸 하트비트
    let roomHbTimer = null;

    const ADJ = ['푸른','은하','순수','초록','고요','깊은','맑은','번쩍','은빛','따뜻'];
    const ANM = ['여우','수달','돌고래','펭귄','고래','고양이','사자','부엉이','라쿤','두더지'];
    const pickNick = () => `${ADJ[Math.floor(Math.random()*ADJ.length)]} ${ANM[Math.floor(Math.random()*ANM.length)]}`;

    const show = el => el.classList.remove('hidden');
    const hide = el => el.classList.add('hidden');
    const setDebug = () => {
      dbgUid.textContent = currentUser?.uid || '-';
      dbgRoom.textContent = currentRoomId || '-';
      dbgRole.textContent = currentRole || '-';
    };
    const nowMs = () => Date.now();
    const roleKey = () => currentRole === 'host' ? 'host' : 'guest';
    const otherRoleKey = () => currentRole === 'host' ? 'guest' : 'host';

    auth.onAuthStateChanged(user => {
      currentUser = user || null;
      if (user) {
        authBadge.textContent = '익명 접속 완료';
        authBadge.title = `projectId: ${firebase.app().options.projectId}`;
        show(home);
      }
      setDebug();
    });

    // ========== 유틸 ==========
    function systemMessage(text) {
      const line = document.createElement('div');
      line.className = 'text-center text-xs text-slate-500 my-2';
      line.textContent = text;
      messages.appendChild(line);
      messages.scrollTop = messages.scrollHeight;
    }

    async function postSystemMessageToRoom(text) {
      if (!currentRoomId) return;
      await db.collection('rooms').doc(currentRoomId).collection('messages').add({
        uid: '__system__',
        text,
        type: 'system',
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(()=>{});
    }

    // ========== 큐(대기열) 기반 자동 매칭 ==========
    async function startMatching() {
      if (!currentUser) return;
      hide(document.getElementById('idleActions'));
      show(matchingBox);

      // 1) "active == true" 인 대기표를 불러오고, createdAt은 클라이언트에서 정렬 (인덱스 필요 없음)
      const raw = await db.collection('waiting').where('active','==',true).get();
      const sortedDocs = raw.docs
        .map(d => ({ ref: d.ref, data: () => d.data() }))
        .sort((a, b) => {
          const ca = a.data().createdAt?.toMillis?.() ?? 0;
          const cb = b.data().createdAt?.toMillis?.() ?? 0;
          return ca - cb;
        })
        .slice(0, 5);

      const others = sortedDocs.filter(d => d.data().uid !== currentUser.uid);

      if (others.length > 0) {
        // 2) 가장 오래 대기한 사람과 트랜잭션 매칭
        const candidate = others[0];
        try {
          const roomId = await db.runTransaction(async (tx) => {
            const candSnap = await tx.get(candidate.ref);
            if (!candSnap.exists) throw new Error('GONE');
            const cand = candSnap.data();
            if (!cand.active || cand.matched) throw new Error('TAKEN');

            const nickA = pickNick(); // host 닉
            const nickB = pickNick(); // guest 닉
            const roomRefNew = db.collection('rooms').doc();
            tx.set(roomRefNew, {
              open: false,
              host: cand.uid,
              guest: currentUser.uid,
              members: [cand.uid, currentUser.uid],
              createdAt: firebase.firestore.FieldValue.serverTimestamp(),
              nicks: { host: nickA, guest: nickB },
              connected: { host: true, guest: true },
              hb: { host: nowMs(), guest: nowMs() },
              ended: false,
              greeted: false
            });

            tx.update(candidate.ref, { active:false, matched:true, roomId: roomRefNew.id });
            const myTicketRef = db.collection('waiting').doc();
            tx.set(myTicketRef, {
              uid: currentUser.uid,
              active:false, matched:true,
              roomId: roomRefNew.id,
              createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            return roomRefNew.id;
          });

          currentRoomId = roomId;
          currentRole = 'guest';
          enterRoomUI();
          return;
        } catch (e) {
          // 경합 실패 → 내가 줄 서기
        }
      }

      // 3) 내가 대기표 생성 (선착)
      waitingDocRef = await db.collection('waiting').add({
        uid: currentUser.uid,
        active: true,
        matched: false,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        hb: nowMs()
      });

      // 대기 하트비트
      waitingHbTimer = setInterval(() => {
        waitingDocRef.update({ hb: nowMs() }).catch(()=>{});
      }, 5000);

      // 4) 내 대기표 구독: roomId 세팅되면 host로 입장
      if (waitingUnsub) waitingUnsub();
      waitingUnsub = waitingDocRef.onSnapshot((snap) => {
        const data = snap.data();
        if (data?.matched && data?.roomId) {
          currentRoomId = data.roomId;
          currentRole = 'host';
          if (waitingHbTimer) { clearInterval(waitingHbTimer); waitingHbTimer = null; }
          if (waitingUnsub) { waitingUnsub(); waitingUnsub = null; }
          waitingDocRef = null;
          enterRoomUI();
        }
      });
    }

    async function cancelMatching() {
      try {
        if (waitingDocRef) {
          await waitingDocRef.update({ active:false }).catch(()=>{});
        }
      } finally {
        if (waitingUnsub) { waitingUnsub(); waitingUnsub = null; }
        if (waitingHbTimer) { clearInterval(waitingHbTimer); waitingHbTimer = null; }
        waitingDocRef = null;
        hide(matchingBox);
        show(document.getElementById('idleActions'));
      }
    }

    // ========== 수동 모드 ==========
    async function createHostRoomManual() {
      if (!currentUser) return;
      hide(document.getElementById('idleActions'));
      show(matchingBox);

      const nickH = pickNick();
      const roomDoc = await db.collection('rooms').add({
        open: true,
        host: currentUser.uid,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        nicks: { host: nickH },
        members: [currentUser.uid],
        connected: { host: true, guest: false },
        hb: { host: nowMs(), guest: 0 },
        ended: false,
        greeted: false
      });

      currentRoomId = roomDoc.id;
      currentRole   = 'host';
      setDebug();

      roomCodeText.textContent = currentRoomId;
      shareHint.classList.remove('hidden');

      if (roomUnsub) roomUnsub();
      roomUnsub = roomDoc.onSnapshot(snap => {
        const d = snap.data();
        if (d?.guest && d.open === false) {
          shareHint.classList.add('hidden');
          enterRoomUI();
        }
      });
    }

    async function joinAsGuestWithCode() {
      if (!currentUser) return;

      const raw = roomCodeInput.value;
      const code = (raw || "").replace(/\s+/g, "").trim();
      if (!code) { alert('방 코드를 입력해 주세요.'); return; }

      hide(document.getElementById('idleActions'));
      show(matchingBox);

      const ref = db.collection('rooms').doc(code);
      const RETRY_LIMIT = 1;

      for (let attempt = 0; attempt <= RETRY_LIMIT; attempt++) {
        try {
          await db.runTransaction(async tx => {
            const s = await tx.get(ref);
            if (!s.exists) throw new Error('NOT_FOUND');

            const room = s.data();
            if (room.host === currentUser.uid) throw new Error('SELF_JOIN');
            if (!room.open) throw new Error('CLOSED');

            const nickG = pickNick();
            const nickH = room.nicks?.host || pickNick();
            tx.update(ref, {
              guest: currentUser.uid,
              open: false,
              nicks: { host: nickH, guest: nickG },
              members: [room.host, currentUser.uid],
              connected: { host: true, guest: true },
              hb: { host: nowMs(), guest: nowMs() },
              ended: false,
              greeted: false
            });
          });

          currentRoomId = code;
          currentRole   = 'guest';
          setDebug();
          enterRoomUI();
          return;

        } catch (e) {
          if (e.code === 'aborted' && attempt < RETRY_LIMIT) {
            await new Promise(r => setTimeout(r, 200));
            continue;
          }
          const byMessage = {
            NOT_FOUND: '방을 찾을 수 없어요. 코드가 맞는지 확인해 주세요.',
            SELF_JOIN: '자신의 방에는 게스트로 입장할 수 없어요.',
            CLOSED: '이미 매칭이 완료된 방이에요. 새로운 코드를 받아주세요.'
          };
          const byCode = {
            'permission-denied': '권한이 없어요. (Firebase 규칙/허용 도메인/App Check 확인)',
            'failed-precondition': '사전 조건이 충족되지 않았어요.',
            'not-found': '방을 찾을 수 없어요.',
            'cancelled': '요청이 취소되었어요.'
          };
          const msg = byMessage[e.message] || byCode[e.code] || '입장에 실패했어요. 코드와 상태를 확인해 주세요.';
          show(document.getElementById('idleActions'));
          hide(matchingBox);
          alert(msg);
          return;
        }
      }
    }

    // ========== 룸 입장 & 하트비트/프레즌스 ==========
    function startRoomHeartbeat() {
      if (!roomRef) return;
      // 즉시 1회
      roomRef.update({
        [`connected.${roleKey()}`]: true,
        [`hb.${roleKey()}`]: nowMs()
      }).catch(()=>{});
      // 5초마다 갱신
      roomHbTimer = setInterval(() => {
        roomRef.update({ [`hb.${roleKey()}`]: nowMs() }).catch(()=>{});
      }, 5000);
    }
    function stopRoomHeartbeat() {
      if (roomHbTimer) { clearInterval(roomHbTimer); roomHbTimer = null; }
    }

    function enterRoomUI() {
      hide(matchingBox);
      show(chatSec);

      roomRef = db.collection('rooms').doc(currentRoomId);
      setDebug();

      // 보호: 같은 UID로 페어링된 방은 종료
      roomRef.get().then(s => {
        const d = s.data() || {};
        const members = d.members || [];
        const uniq = new Set(members);
        if (uniq.size < 2) {
          systemMessage('⚠️ 매칭 오류(동일 사용자 감지). 다시 시도해 주세요.');
          leaveRoom(true);
          return;
        }
        const myNick = currentRole === 'host' ? d.nicks.host : d.nicks.guest;
        const otherNick = currentRole === 'host' ? d.nicks.guest : d.nicks.host;
        nickbar.textContent = `${myNick} • 상대: ${otherNick || '대기중...'}`;
      });

      // 하트비트 시작
      startRoomHeartbeat();

      // 방 상태 구독
      if (roomUnsub) roomUnsub = null;
      roomUnsub = roomRef.onSnapshot(snap => {
        const d = snap.data() || {};
        const otherHb = d.hb?.[otherRoleKey()] || 0;
        const alive = (nowMs() - otherHb) <= 10000; // 10초 내 신호
        statusbar.textContent = alive ? '상대 연결됨' : '상대 입장 대기중...';

        if (d.ended) {
          systemMessage('상대가 나갔습니다. (채팅 종료됨)');
        }
      });

      // 메시지 구독
      if (msgUnsub) msgUnsub = null;
      msgUnsub = roomRef.collection('messages')
        .orderBy('createdAt', 'asc')
        .onSnapshot(snap => {
          messages.innerHTML = '';
          snap.forEach(doc => {
            const m = doc.data();
            if (m.type === 'system') {
              const line = document.createElement('div');
              line.className = 'text-center text-xs text-slate-500 my-2';
              line.textContent = m.text;
              messages.appendChild(line);
              return;
            }
            const isMe = m.uid === currentUser.uid;
            const wrap = document.createElement('div');
            wrap.className = `flex ${isMe ? 'justify-end' : ''}`;
            wrap.innerHTML =
              `<div class="max-w-[80%] px-3 py-2 rounded-xl ${isMe ? 'bg-indigo-600 text-white' : 'bg-slate-200 text-slate-900'}">${m.text}</div>`;
            messages.appendChild(wrap);
          });
          messages.scrollTop = messages.scrollHeight;
        });

      // 연결 완료 안내(1회)
      roomRef.get().then(s => {
        const d = s.data() || {};
        const both = d.connected?.host && d.connected?.guest;
        if (both && !d.greeted) {
          roomRef.update({ greeted: true }).then(() => {
            postSystemMessageToRoom('✅ 연결 완료! 이제 메시지를 주고받을 수 있어요.');
          }).catch(()=>{});
        }
      });
    }

    // ========== 종료/전송 ==========
    async function leaveRoom(navigateHome = true) {
      try {
        stopRoomHeartbeat();
        if (currentRoomId) {
          const ref = db.collection('rooms').doc(currentRoomId);
          await ref.collection('messages').add({
            uid: '__system__', type: 'system', text: '상대가 나갔습니다.',
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          });
          await ref.update({
            [`connected.${roleKey()}`]: false,
            [`hb.${roleKey()}`]: 0,
            ended: true
          }).catch(()=>{});
        }
      } finally {
        if (msgUnsub) { msgUnsub(); msgUnsub = null; }
        if (roomUnsub) { roomUnsub(); roomUnsub = null; }
        currentRoomId = null; currentRole = null;
        hide(chatSec);
        show(home); show(document.getElementById('idleActions'));
        messages.innerHTML = '';
        statusbar.textContent = '';
        setDebug();
      }
    }

    async function sendMessage(text) {
      if (!text || !currentRoomId) return;
      await db.collection('rooms').doc(currentRoomId).collection('messages').add({
        uid: currentUser.uid,
        text,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(()=>{});
    }

    // ========== 이벤트 ==========
    btnStart.addEventListener('click', startMatching);
    btnCancel.addEventListener('click', cancelMatching);
    btnLeave.addEventListener('click', () => leaveRoom(true));

    form.addEventListener('submit', e => {
      e.preventDefault();
      const t = input.value.trim();
      if (!t) return;
      // 선택: 상대 하트비트 확인 후 전송
      roomRef.get().then(s => {
        const d = s.data() || {};
        const otherHb = d.hb?.[otherRoleKey()] || 0;
        const alive = (nowMs() - otherHb) <= 10000;
        if (!alive) {
          systemMessage('⏳ 아직 상대가 완전히 연결되지 않았어요. 잠시만 기다려 주세요.');
          return;
        }
        sendMessage(t);
        input.value = '';
      });
    });

    btnHostManual.addEventListener('click', createHostRoomManual);
    btnJoinManual.addEventListener('click', joinAsGuestWithCode);
    btnCopyCode.addEventListener('click', async () => {
      const code = roomCodeText.textContent.trim();
      if (!code) return;
      try { await navigator.clipboard.writeText(code); btnCopyCode.textContent='복사됨'; setTimeout(()=>btnCopyCode.textContent='복사',1000); }
      catch { alert('복사 실패! 코드를 직접 선택해 복사해 주세요.'); }
    });

    // 탭 종료 시 대기표/방 정리
    window.addEventListener('beforeunload', () => {
      if (waitingDocRef) {
        waitingDocRef.update({ active:false }).catch(()=>{});
      }
      if (currentRoomId) {
        stopRoomHeartbeat();
        const ref = db.collection('rooms').doc(currentRoomId);
        ref.collection('messages').add({
          uid: '__system__', type: 'system', text: '상대가 나갔습니다.',
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        }).catch(()=>{});
        ref.update({ [`connected.${roleKey()}`]: false, [`hb.${roleKey()}`]: 0, ended: true }).catch(()=>{});
      }
    });
  </script>
</body>
</html>
